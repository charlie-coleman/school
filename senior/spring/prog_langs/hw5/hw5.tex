\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{drawstack}
\usetikzlibrary{shapes.multipart}

\lstset {
	basicstyle=\ttfamily
}

\begin{document}
	\begin{center}
		\begin{large}Programming Languages HW \#5\end{large}
		
		\hfill Charlie Coleman
		
		\begin{enumerate}
			\item \begin{itemize}
				\item[\textbf{C:}] Print statements: \begin{enumerate}
					\item[7.] x - line 5 def, y - line 3 def
					\item[11.] x - line 5 def, y - line 8 def
					\item[13.] x - line 2 def, y - line 3 def
					\item[15.] x - line 2 def, y - line 3 def
				\end{enumerate}
				Output:
				\begin{lstlisting}
6, 4
6, 7
2, 4
2, 4
				\end{lstlisting}
				\item[\textbf{C\#:}] Print statements: \begin{itemize}
					\item[7.] x - line 5 def, y - line 8 def
					\item[11.] x - line 5 def, y - line 8 def
					\item[13.] x - line 2 def, y - line 3 def
					\item[15.] x - line 2 def, y - line 3 def
				\end{itemize}
				Output:
				\begin{lstlisting}
6, 7
6, 7
2, 4
2, 4
				\end{lstlisting}
				\item[\textbf{M-3:}] Print statements: \begin{enumerate}
					\item[7.] x - line 5 def, y - line 8 def
					\item[11.] x - line 5 def, y - line 8 def
					\item[13.] x - line 2 def, y - line 3 def
					\item[15.] x - line 2 def, y - line 3 def
				\end{enumerate}
				Output:
				\begin{lstlisting}
9, 7
9, 7
2, 4
2, 4
				\end{lstlisting}		 
			\end{itemize}
			\item \begin{enumerate}
				\item Output:
				\begin{lstlisting}
5
3
1
1
				\end{lstlisting}
			\item 
			\tikzset{loopy/.style={min distance=0.5cm}}			
			\begin{tikzpicture}[baseline=-0.8cm]
				\drawstruct{(0, 0)}
				\structcell[freecell]{...}
				\structcell[freecell]{Subroutine A}
				\coordinate (as) at (currentcell.east);
				\coordinate (ad) at (currentcell.west);
				\structcell[freecell]{Subroutine R}
				\coordinate (r3s) at (currentcell.east);
				\coordinate (r3d) at (currentcell.west);
				\structcell[freecell]{Subroutine R}
				\coordinate (r2s) at (currentcell.east);
				\coordinate (r2d) at (currentcell.west);
				\structcell[freecell]{Subroutine R}
				\coordinate (r1s) at (currentcell.east);
				\coordinate (r1d) at (currentcell.west);
				\structcell[freecell]{Subroutine B}
				\coordinate (bs) at (currentcell.east);
				\coordinate (bd) at (currentcell.west);
				\structcell[freecell]{Main}
				\coordinate (ms) at (currentcell.east);
				\coordinate (md) at (currentcell.west);
				\structcell[freecell]{...}
				
				\path[loopy, ->] ([yshift=-0.1cm]as) edge[bend left=100] node[right] {static} ([yshift=0.1cm]bs);
				\path[loopy, ->] ([yshift=-0.1cm]r3s) edge[bend left=90] node {} ([yshift=0.1cm]bs);
				\path[loopy, ->] ([yshift=-0.1cm]r2s) edge[bend left=80] node {} ([yshift=0.1cm]bs);
				\path[loopy, ->] ([yshift=-0.1cm]r1s) edge[bend left=70] node {} ([yshift=0.1cm]bs);
				\path[loopy, ->] ([yshift=-0.1cm]bs) edge[bend left=100] node[right] {static} ([xshift=0.7cm,yshift=0.1cm]ms);
				
				\path[loopy, ->] ([yshift=-0.1cm]ad) edge[bend right=100] node[left] {dynamic} ([yshift=0.1cm]r3d);
				\path[loopy, ->] ([yshift=-0.1cm]r3d) edge[bend right=100] node[left] {dynamic} ([yshift=0.1cm]r2d);
				\path[loopy, ->] ([yshift=-0.1cm]r2d) edge[bend right=100] node[left] {dynamic} ([yshift=0.1cm]r1d);
				\path[loopy, ->] ([yshift=-0.1cm]r1d) edge[bend right=100] node[left] {dynamic} ([yshift=0.1cm]bd);
				\path[loopy, ->] ([yshift=-0.1cm]bd) edge[bend right=100] node[left] {dynamic} ([xshift=-0.7cm,yshift=0.1cm]md);
			\end{tikzpicture}
			\item A will follow the static links up the call chain to find the value of g
			\end{enumerate}
			\item \begin{enumerate}
				\item Output: \begin{lstlisting}
0, 0
0, 0
0, 0
0, 0
0, 0
				\end{lstlisting}
				\item Output: \begin{lstlisting}
11, 0
11, 7
1, 7
1, 18
1, 7

				\end{lstlisting}
			\end{enumerate}
			\item \begin{enumerate}
				\item 1
				\item -3
				\item -2
			\end{enumerate}
			\item false, error. It does not make sense for a language to check both boolean expressions when either being false means the return is false. C checks the left-most expression on the and, if it is true it checks the other. The division by zero returns an error here. 
			\item Structural - all. Strict name - none. Loose name - A \& B
			\item C/Fortran: can result in simpler case statements when a default/others case is not a requirements. This can cause hard to diagnose errors if a case is supposed to get caught but isn't beign caught. 
			
			Pascal/Modula: What I would call the worst of both worlds. Only helpful when you know inputs won't be outside of the covered ranges. Does not warn you when a value is not being covered, but will throw an error when those values come up. Does help some with debugging values that should be covered but aren't.
			
			Ada: requires more code in some cases as you basically must include an others case. Doesn't allow compilation of code missing cases, which leads to less dynamic bugs.
			
			My preference: Ada. This is prevents errors and leads to more bug resistant code. Is used in some languages important to Computer Eng, like VHDL.
			
			\item \texttt{buzz} may have overwritten some or all of the functions of \texttt{fizz}. If one of these functions is changed to return a different type, it could cause issues with the calling function, as it would expect the type that is defined in \texttt{fizz} but recieve the return type from \texttt{buzz}.
		\end{enumerate}
	\end{center}
\end{document}