\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{sectsty}
\usepackage{comment}
\usepackage{titling}
\usepackage{hyperref}

\sectionfont{\large}
\subsectionfont{\normalsize}

\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mypurp}{rgb}{0.5,0,0.5}

\lstset{
	language=Perl,
	basicstyle=\ttfamily\small,
	numbers=left,
 	numberstyle=\small,
	frame=tb,
	tabsize=2,
	columns=fullflexible,
	xleftmargin=\parindent,
	showstringspaces=false,
	showtabs=false,
	keepspaces,
	commentstyle=\color{commentgreen},
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	identifierstyle=\color{mypurp},
	captionpos=t
}

\renewcommand*{\lstlistingname}{Example}

\newcommand{\li}[1]{\lstinline{#1}} % hello {}
\newcommand{\disapper}[1]{~}

\begin{document}

	\begin{titlingpage}
	\vspace*{0.1\paperheight}

	\begin{center}
		\begin{Large}\textbf{Homework 6: Features of Perl\\Programming Languages}\end{Large}
	\end{center}
	
	\hfill Charlie Coleman\\
	
	\tableofcontents
	
	\end{titlingpage}
	
	\section{Overview}
	
	Perl is an interpreted language developed mainly for text manipulation. It has grown to be usable for almost any application. It's goal is ease of use \& efficient code\cite{perldocs}. It claims to focus on these over "aesthetic" programming languages, which focus on tiny/elegant/minimal code.
	
	Perl includes support for procedural \& object-oriented programming. It has a strong focus on modules, which can be added for any number of specialized features. Overall it can be compared to Python, as both are high-level, interpreted programming languages that gain a lot of functionality through modules/imports. Both Perl and Python go without explicit variable typing. Here is an example of Perl code, a simple "Hello, World!".
	
\begin{lstlisting}[caption={Hello, World!}]
print "Hello, World!\n";
\end{lstlisting}

	\section{Features}

	\subsection{Functional? Imperative?}
	
	Or both? Perl is typically used as an imperative language, but it is also able to be used as a functional language, fulfilling all of the commonly required features of a functional language\cite{funcprog}. For example, Perl supports first class functions and higher order functions\cite{hop}. This means that functions can be passed as parameters, and that functions can take functions as inputs and/or return a function. Here is some example code for these features.
	
	\lstinputlisting[caption=Functional Programming]{./code/functional.pl}
	
	This is a fairly simple chunk of code that adequately displays some functional programming concepts. First, we create a first class function named \li{$first_class} that prints "hello". Next, we create a higher order function called \li{higher_order} which recieves a function as input, calls it, then returns it. Then we create a variable, \li{$should_print_hello}, which is set equal to the higher order function that is passed the first class function. Then we call that variable. When run, this code matches the expected output, simply printing "hello" twice.
	
	\subsection{Lexical Scoping}
	
	Perl is a lexically scoped language\cite{perldocs}, however, when a variable is created in Perl, its scope depends on how it was declared. Using \li{my} to declare a variable will create a lexically scoped variable, and this is the recommended approach. If the \li{my} is left out, however, the variable will be a global variable. This causes the variables to behave like they are dynamically-scoped in some situations. But as this is considered bad practice, we will focus on the lexical scoping with \li{my}. For example, in this code:
	
	\lstinputlisting[caption=Lexical Scoping]{./code/lexscope.pl}
	
	Because Perl is lexically scoped, the output of this program is 2. This is because when \li{fcn2} is called, the \li{$x} it refers to is determined at compile time to be the innermost definition of \li{$x}, which is the variable definition labeled as x1. If this were a dynamically scoped programming language, we would expect this code to output a 1, as the \li{$x} marked as x2 would be pushed to the stack after x1, and the assignment in \li{fcn2} would be applied to this x2. After \li{fcn3} is completed, x2 would be removed from the stack and \li{print($x, "\n")} would print 1.
	
	\subsection{Scopes \& Modules}
	
	All scopes in Perl can nest within each other. This can be seen in Example 3, we can nest functions within each other. These scopes are open, as the functions nested inside of a function are accessible from the outside without calling the enclosing function. For example:
	
	\lstinputlisting[caption=Nested Scopes]{./code/nestedscopes.pl}
	
	In this example, all of the function calls will be successfully executed, and we will see all of the print statements executed.
	
	Perl also supports modules. Modules are imported using the \li{use} keyword, and are open scope as well. The functions within a module can be used without explicitly importing them, or accessing them from the module as an object. This is shown in the code below.
	
	\lstinputlisting[caption=Modules]{./code/modules.pl}
	
	This code uses the Math::Trig module from Perl, which includes the atan function. This code will correctly print out the inverse tangent of 1.
	
	\subsection{Recursion}
	
	Recursion is accomplished by calling the subroutine within the subroutine itself. This a very common way of doing recursion, so it should look fairly familiar to most people who have used Python/C/Java.
	
	\lstinputlisting[caption=Recursion]{./code/gcd.pl}
	
	\subsection{Type Checking}
	
	Whether Perl is a weakly \& dynamically typed language. Perl only has 3 types: scalars, arrays, and hashes\cite{perldocs}. These are designated by the character before the variable name; \$, @, and \% correspondingly. The scalar data type encompasses everything like int, float, string, etc. Any variable that is a scalar can be set to any of these at any time, without complaint by the compiler. Arrays in Perl can contain any combination of scalar variables, and are variable in size.
	
	\lstinputlisting[caption=Type Checking]{./code/typechecking.pl}
	
	In the code above, you can see various assignments to different variables. The results are mostly as expected when compared to the rules defined above, except for the last print statement. When a scalar data type is set equal to an array, it only gets the number of elements in the array and none of the elements.
	
	\subsection{Overloading, Coercion, and Polymorphism}
	
	Perl will coerce all scalar values into the "proper" format for its functions. Scalars do not differentiate between ints and floats, instead treating both as "numbers". It also lacks any support for booleans, instead using 0/null/undefined for FALSE, and anything else as TRUE. This means that in code like below, we can concatenate any combination of strings/numbers, we can add strings to numbers, etc. If a string is not in the form of a number, Perl resolves it to be 0 when treated like a number.
	
	\lstinputlisting[caption=Coercion]{./code/coercion.pl}
	
	Overloading in Perl is done differently than in a lot of Object Oriented programming languages. It relies on examining the parameters passed to a function and changing behavior based on them. This is because the language is weakly \& dynamically typed, there is no restriction on what is passed to a function. Therefore, when calling a constructor or function, we can pass any number of different scalars, arrays, instances of classes, etc. All will be passed to the same function/constructor, and that will handle all the different supported options\cite{ol}.
	
	Polymorphism is supported by Perl. When a function is called on an object, Perl checks to see if that method is supplied by the object, and calls that function. This allows the same function name to be used in multiple classes without conflict. If the function is not supplied, it checks base classes for the object, then the universal set of functions. 
	
	\subsection{Order of Operations}
	
	Operator precedence in Perl follows mathematics for the most part. Operators of the same precedence are evaluated from left to right. For example, \li{8 + 2 * 17 == 42}, not \li{170} and \li{3 - 2 - 1} $\rightarrow$ \li{1 - 1 == 0} and not \li{3 - 2 - 1} $\rightarrow$ \li{3 - 1 == 2}.
	
	Perl also considers \li{&&} and \li{||} as 'short-circuit' operators. This can be seen in the following example.
	
	\lstinputlisting[caption=Short Circuiting]{./code/short.pl}
	
	When run, this code prints a 1, which implies that Perl supports boolean short circuiting. In other words, when the \li{||} operator encounters a TRUE in the first term, or the \li{&&} operator encounters a FALSE, it does not need to check the second term, because the statement will evaluate to TRUE/FALSE no matter what. This can be useful when you want to check the value of a variable that may not exist. Checking its value may through an error if it is not initialized, but checking if the var exists and checking its value will solve this conundrum.
	
	\section{Conclusion}
	
	Perl is a very interesting language. It is the seeming opposite of a programming language like Java, which has strong, static typing, closed scope, etc. I feel that it focus a bit too much on offering every option under the sun to the programmer, instead of narrowing its focus to a few features. It does not constrict itself to Object Oriented/Functional/Procedural/etc, instead allowing the programmer to utilize any of these paradigms depending on how the code is written. This could prove to be very useful in some cases, but provides a bit of a barrier to entry as the user can't look at a set of 'best practices' for the language.
	
	\begin{thebibliography}{4}
		\bibitem{perldocs} Robert, Kirrily. \textit{Perl Programming Documentation}. \texttt{https://perldoc.perl.org/}
		\bibitem{funcprog} Functional Programming, \texttt{http://wiki.c2.com/?FunctionalProgramming}
		\bibitem{hop}Dominus, Mark Jason. \textit{Higher-Order Perl: Transforming Programs with Programs}. Morgan Kaufmann Publ., 2009.
		\bibitem{ol} Overloading, \texttt{https://www.perl.com/pub/2003/07/22/overloading.html/}
	\end{thebibliography}
	\addcontentsline{toc}{section}{References}	

\end{document}