\documentclass[titlepage, 12pt]{article}

\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{amssymb, amsmath}

\newcommand{\ttt}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\hi}{\hangindent=0.5in}

\usepackage{listings}
\lstdefinelanguage{AVR}{
	keywords={
		clr,ldi,lpm,cp,cpc,brge,add,adc,brlt,dec,brne,rjmp,jmp,dseg,cseg,db,dw,byte,subi,brne,cpi,inc,dec,breq,mul,mov
	},
	morecomment=[l];,
	sensitive=false
}
\usepackage{xcolor}
\colorlet{keyword}{blue!100!black!80}
\colorlet{comment}{green!30!black!100}
\lstdefinestyle{AVR}{
	language     = AVR,
	keywordstyle = \color{keyword},
	commentstyle = \color{comment},
	tabsize=4,
	basicstyle=\small\ttfamily
}


\begin{document}
	
	\title{Control Flow, Arrays, and Strings\\Microprocessors Lab\\ECE 3226-37}
	\author{Charlie Coleman \\ Lab Partner: Amy Guo}
	\date{October 9, 2017}
	
	\maketitle
	
	\noindent\large{\textbf{Objective:}}
	
	The purpose of this lab is to experiment with control flow in assembly. For example, we used different instructions to compare and branch. Then we used new types like array and string. We also experimented with constants from program memory. \\
	
	\noindent\large{\textbf{Equipment:}}
	
	AVR Studio 7 \\
	
	\noindent\large{\textbf{Procedure:}}
	
	The program was given as part of the hand out. One part of the program adds the elements in an array for four 8-bit unsigned numbers. Then the result is saved as a 16-bit word in the R10: R11 register pair. The second part adds two 16-bit numbers, and stores the result as a 16-bit word. The last part loops over an ASCII string. \\
	
	\begin{lstlisting}[style=AVR]
	Start: 
		ldi zl, LOW(2*Byte_Array) 
		ldi zh, HIGH(2*Byte_Array) 
		
		; Summing four 8-bit words 
		clr r10 
		clr r11 
		clr r1 
		ldi r16, 0x04 
	Loop1: 
		lpm r0, z+ 
		
		add r10, r0 
		adc r11, r1 
		
		subi r16, 1 
		brne Loop1 
		
		; Summing two 16-bit words 
		ldi zl, LOW(2*Word_Array) 
		ldi zh, HIGH(2*Word_Array) 
		
		lpm r24, z+ 
		lpm r25, z+ 
		
		lpm r0, z+ 
		lpm r1, z+ 
		
		add r24, r0 
		adc r25, r1 
		
		; Iterating through an ASCII string 
		ldi zl, LOW(2*String1) 
		ldi zh, HIGH(2*String1) 
	
	Loop2: 
		lpm r16, z+ 
		
		cpi r16, 0 
		brne Loop2 
	
	End: 
	rjmp End 
	
	;============= 
	; Declarations 
	
	Byte_Array: 
	.DB 123,45,67, 89; a list of four bytes 
	
	Word_Array: 
	.DW 2137,984,  ; a wordwise list of labels 
	
	String1: 
	.DB "This is a text.", 0; a list of byte characters 
	\end{lstlisting}~\\
	
	\noindent\textbf{Results for Part 1:}
	
	\noindent\begin{tabular}{|l|l|}
		\hline Part & Result \\ \hline
		Default & \texttt{0x0144} \\
		Part 1c & \texttt{0x0144} \\
		Part 1d & \texttt{0x0C31} \\
		Part 1f & \texttt{0x0F} \\ \hline
	\end{tabular} \\\\
	
	\noindent\textbf{1a)}
	
	\hi \textbf{Question 1.1:} In this program, what is the purpose of the \ttt{LPM} instruction? For this instruction the second operand is always \ttt{Z+}. Which register(s) does \ttt{Z} constitute, and what is the \ttt{+} for? Why is this program using register \ttt{Z} instead of registers \ttt{X} or \ttt{Y} with the \ttt{LPM} instruction?
	
	\hi \textbf{Answer:} The \ttt{LPM} instruction is used to load a byte from the program memory. \ttt{Z} is \ttt{R31:R30}, and the \ttt{+} is a post-increment, so after the command executes and the \ttt{Z} register is updated with \ttt{Z+1}. \ttt{Z} is used because the \ttt{LPM} instruction only uses \ttt{Z}.\\
	
	\hi \textbf{Question 1.2:} When using the \ttt{.DB} and \ttt{.DW} (and similar) directives, it is best to place such constant declarations at the end of the program code (after the \ttt{rjmp End} instruction). What happens if you place (cut \& paste) them before the \ttt{rjmp Init} instruction? Does the program still work? If so, will it necessarily work with any constant declarations?
	
	\hi \textbf{Answer:} If the \ttt{.DB} and \ttt{.DW} are placed at the beginning of the program code, the output is the same. If the constant is being saved in the data segment instead of the code segment (\ttt{.DSEG}), you must remember to place a \ttt{.CSEG} directive before the program code starts.\\
	
	\noindent\textbf{1b)}
	
	\hi \textbf{Question 1.3:} In the first the first part of the program, we are iterating (looping) over an array of four 8-bit unsigned numbers, and saving the sum over all the numbers as a 16-bit value in the register pair \ttt{R10:R11}. When we load an element of the array from program memory, what register is it being stored in?
	
	\hi \textbf{Answer:} The element is being stored in \ttt{R0}. \\
	
	\hi \textbf{Question 1.4:} What is the purpose of register \ttt{R1}?
	
	\hi \textbf{Answer:} In this program, \ttt{R1} is used for the add with carry command (\ttt{ADC}). \ttt{ADC} is not an immediate command, so both operands must be registers.\\
	
	\hi \textbf{Question 1.5:} Using this method, would it be possible to take the sum of an array of \underline{signed} numbers? Why or why not?
	
	\hi \textbf{Answer:} Yes, \ttt{ADD} and \ttt{ADC} both work with signed numbers.\\
	
	\hi \textbf{Question 1.6:} This part of the program uses a loop that iterates (loops) four times. What register(s) and instruction(s) are used to enable the loop to iterate (loop) the desired number of times?
	
	\hi \textbf{Answer:} \ttt{R16} holds the number of loops that the program will execute. \ttt{R16} is decremented in each loop, and the command \ttt{BRNE} is used to branch until the \ttt{Z} bit in \ttt{SREG} is 1.\\
	
	\noindent\textbf{1c)} In 1c, the given code was modified so that it would iterate in a different fashion.
	
	\begin{lstlisting}[style=AVR]
	start:
		ldi r16, 0x04
	loop1:
		subi r16, 1
		brne Loop1
	\end{lstlisting}~\\
	
	\noindent\textbf{1d)} In 1d, the given program was modified so that it used a loop for the 16-bit addition.
	
	\begin{lstlisting}[style=AVR]
	ldi zl, LOW(2*Word_array)
	ldi zh, HIGH(2*Word_array)
	
	clc
	clr r0
	clr r1
	ldi r17, 2
	loop2:
		lpm r24, z+
		lpm r25, z+
		
		add r0, r24
		adc r1, r25
		
		subi r17, 1
		brne loop2
	\end{lstlisting}~\\
	
	\noindent\textbf{1e)}
	
	\hi \textbf{Question 1.7:} The third part of the program iterates over the ASCII string. Which register shows the value of the current ASCII character in the string being read?
	
	\hi \textbf{Answer:} \ttt{R16} holds the value of the ASCII character.\\
	
	\hi \textbf{Question 1.8:} Strings of ASCII characters commonly end in a terminator, which signifies the end of the string. What is the hexadecimal value of the terminator used in this ASCII string? Why is it desirable to use an unprintable character as the string terminator?
	
	\hi \textbf{Answer:} \texttt{0x0} is typically used for the terminator of an ASCII string. An unprintable character is used because if the code is written incorrectly, it will not display the terminator at the end of the string.\\
	
	\hi \textbf{Question 1.9:} This part of the program uses a loop to iterate over the string, but the loop iteration condition here is different than used previously. What test is being performed to determine when the loop should stop iterating?
	
	\hi \textbf{Answer:} This part of the program uses an immediate comparison between the loaded byte and 0. If the loaded byte is equal to zero, the program stops looping. This is accomplished using the \ttt{BRNE} command.\\
	
	\noindent\textbf{1f)} In 1f, the last part of the given program was modified so that it found the length of the string.
	
	\begin{lstlisting}[style=AVR]
	ldi zl, LOW(2*String1)
	ldi zh, HIGH(2*String1)
	
	clr r0
	loop3:
		lpm r16, z+
		cpi r16, 0
		breq end
		subi r0, -1
		cpi r16, 0
		brne loop3
	
	end:	rjmp end
	\end{lstlisting}~\\\\
	
	
	\noindent\textbf{2a)} We created a program to increment through the capital letters of the alphabet to output the corresponding ASCII value for each letter.
	
	\begin{lstlisting}[style=AVR]
	ldi r16, 0x41 
	ldi r17, 0x1A 
	ldi r18, 0xFF 
	out DDRB, r18 
	
	loop: out PORTB, r16 
		subi r16, -1 
		subi r17, 1 
		brne loop 
	end: rjmp end 
	\end{lstlisting}~\\
	
	\hi \textbf{Question 2.1:} There are various ways (checks) you could use to terminate your loop for this program. What is an alternate method for terminating the loop for this program?
	
	\hi \textbf{Answer:} In our code, we used a counter to terminate the loop, but alternatively you could use an immediate comparison between the register holding the current letter and the ASCII value of Z, stopping when the letter output is "Z".\\
	
	\noindent\textbf{2b)} This program iterates over the given array of 16-bit unsigned numbers. Its job is to only add the number if the value is greater than 100.
	
	\begin{lstlisting}[style=AVR]
	clr r0 
	clr r1 
	clr r2 
	
	ldi zl, low(num_list << 1) 
	ldi zh, high(num_list << 1) 
	
	ldi r16, 0x64 
	ldi r17, 0x00 
	ldi r18, 0x10 
	clr r6 
	
	loop1: 
		lpm r19, z+ 
		lpm r20, z+ 
		
		cp r16, r19 
		cpc r17, r20 
		brge pt2 
		
		add r0, r19 
		adc r1, r20 
		adc r2, r6 
	
	pt2: dec r18 
		brne loop1 
	
	end: rjmp end 
	
	.CSEG 
	num_list: .DW 573, 16, 8, 39, 9162, 483, 1602, 198,
				  3507, 215, 33, 598, 63, 882, 100, 120 
	\end{lstlisting}~\\
	
	\hi \textbf{Question 2.2:} Is your final sum what you would expect? State the result.
	
	\hi \textbf{Answer:} The final sum is as expected. We received an output of \texttt{0x43BC}.\\
	
	\hi \textbf{Question 2.3:} How would your program need to be different if the values were signed values, such that you ignore values between -100 and 100, and add the \underline{magnitude} of the rest of the numbers to the sum? Write the modified program.
	
	\hi \textbf{Answer:} To modify the program, I would include two comparisons, one to check if the data was greater than 100, one to check if the data is less than -100. If neither are the case, skip to the end.
	\setlength\parindent{0.5in}
	\begin{lstlisting}[style=AVR, xleftmargin=0.5in]
	clr r0
	clr r1
	clr r2
	
	ldi zl, low(num_list << 1)
	ldi zh, high(num_list << 1)
	
	ldi r16, 0x64
	ldi r17, 0x00
	ldi r21, 0x9C
	ldi r22, 0xFF
	ldi r18, 0x10
	clr r6
	
	loop1:
		lpm r19, z+
		lpm r20, z+
		
		cp r16, r19
		cpc r17, r20
		brlt addnum
		cp r21, r19
		cpc r22, r20
		brge addnum
		jmp pt2
	
	addnum:
		add r0, r19
		adc r1, r20
		adc r2, r6
	
	pt2: dec r18
		brne loop1
	
	end: rjmp end
	
	.CSEG
	num_list: .DW 573, 16, 8, 39, 9162, 483, 1602, 198, 
				  3507, 215, 33, 598, 63, 882, 100, 120
	\end{lstlisting}~\\
	
	\noindent\textbf{2c)} This program calculates the powers of unsigned integers. We used the .DB directive to create two 8-bit unsigned integers. Then we loaded them from program memory to calculate the exponent. The answer was sent to R0:R1 to be stored as a 16-bit value. 
	
	\begin{lstlisting}[style=AVR]
	LDI ZL, LOW(Base<<1) 
	LDI ZH, HIGH(Base<<1) 
	LPM R16, Z 
	LDI ZL, LOW(Expon<<1) 
	LDI ZH, HIGH(Expon<<1) 
	LPM R17, Z 
	
	CLR R19 
	CLR R20 
	INC R19 
	CLR R21 
	CLR R22 
	INC R21 
	
	LOOP: 
		CPI R17, 0 
		BREQ END 
		MUL R21, R16; result goes to R0:R1 
		MOV R19, R0 
		MOV R20, R1 
		MUL R22, R16 
		ADD R20, R0 
		MOV R21, R19 
		MOV R22, R20 ; Answer stored in R22:R21 
	
		DEC R17 
		BRNE LOOP 
	
	END: RJMP END 
	
	.CSEG 
	Base: .DB 0x02 
	Expon: .DB 0x0F 
	\end{lstlisting}~\\
	
	\noindent\textbf{2d)} This program compares two strings. When the strings are the same, R0 will be one. If the strings are different, R0 will be zero. 
	
	\begin{lstlisting}[style=AVR]
	.CSEG 
	
	CLR R5 
	CLR R6 
	
	Loop: 
		LDI ZL, LOW(String1<<1) 
		LDI ZH, HIGH(String1<<1) 
		ADD ZL, R5 
		ADC ZH, R6 
		LPM R16, Z+ 
		
		LDI ZL, LOW(String2<<1) 
		LDI ZH, HIGH(String2<<1) 
		ADD ZL, R5 
		ADC ZH, R6 
		LPM R17, Z+ 
		
		INC R5 
		CP R16, R17 
		BREQ endCheck 
		BRNE notEqual 
	
	endCheck: 
		CPI R16, 0 
		BREQ EQUAL 
		BRNE Loop 
	
	EQUAL: 
		CLR R0 
		INC R0 
		JMP end 
	
	notEqual: 
		CLR R0 
	
	end: 
	RJMP end 
	
	.CSEG 
	String1: .DB "This is a good book.", 0 
	String2: .DB "This is a good book. The other one is better.", 0
	\end{lstlisting}~\\
	
	\noindent\large{\textbf{Discussion/Conclusion:}} 
	
	In this experiment, we learned how to utilize branch functions in AVR Assembly programs. These commands can be used to implement functionality similar to conditional statements in a high level programming language (if, while, for). We also learned to utilize the program memory as a storage space for information. This data can then be loaded into a register within the program. Lastly, we learned to use the \ttt{MUL} command to multiply two values, which stores the value to \ttt{R0:R1}.
	
	We encountered errors in the lab when our comparisons and branch commands were implemented incorrectly in 2c. This caused the result to be one degree higher than calculated. After changing the code, we were able to correct the error and receive the calculated answer. Another problem we encounter was using the \ttt{.DB} directive after a \ttt{.DSEG} directive, which does not work. The strings had to be moved after \ttt{.CSEG}, and the \ttt{LDI} commands had to be edited, multiplying the address of the strings by two.
	
	Overall, this lab was a success as all parts output the calculated values.
	
\end{document}